/* https://github.com/timohausmann/quadtree-js.git v2.0.0 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).Quadtree=e()}(this,(function(){"use strict";class t{constructor(t){this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height,this.data=t.data||{}}static getIndex(t,e){const s=[],i=e.x+e.width/2,h=e.y+e.height/2,n=t.y<h,o=t.x<i,r=t.x+t.width>i,c=t.y+t.height>h;return n&&r&&s.push(0),o&&n&&s.push(1),o&&c&&s.push(2),r&&c&&s.push(3),s}}class e{constructor(t,e=10,s=4,i=0){this.bounds=t,this.max_objects=e,this.max_levels=s,this.level=i,this.objects=[],this.nodes=[]}getIndex(e){var s;return(e.getIndex||(null===(s=e.constructor)||void 0===s?void 0:s.getIndex)||t.getIndex)(e,this.bounds)}split(){const t=this.level+1,s=this.bounds.width/2,i=this.bounds.height/2,h=this.bounds.x,n=this.bounds.y,o=[{x:h+s,y:n},{x:h,y:n},{x:h,y:n+i},{x:h+s,y:n+i}];for(var r=0;r<4;r++)this.nodes[r]=new e({x:o[r].x,y:o[r].y,width:s,height:i},this.max_objects,this.max_levels,t)}insert(t){var e,s=0;if(this.nodes.length)for(e=this.getIndex(t),s=0;s<e.length;s++)this.nodes[e[s]].insert(t);else if(this.objects.push(t),this.objects.length>this.max_objects&&this.level<this.max_levels){for(this.nodes.length||this.split(),s=0;s<this.objects.length;s++){e=this.getIndex(this.objects[s]);for(var i=0;i<e.length;i++)this.nodes[e[i]].insert(this.objects[s])}this.objects=[]}}retrieve(t){var e=this.getIndex(t),s=this.objects;if(this.nodes.length)for(var i=0;i<e.length;i++)s=s.concat(this.nodes[e[i]].retrieve(t));return s=s.filter((function(t,e){return s.indexOf(t)>=e}))}clear(){this.objects=[];for(var t=0;t<this.nodes.length;t++)this.nodes.length&&this.nodes[t].clear();this.nodes=[]}}class s{constructor(t){this.x=t.x,this.y=t.y,this.r=t.r,this.data=t.data||{}}static getIndex(t,e){const i=[],h=e.width/2,n=e.height/2,o=e.x+h,r=e.y+n,c=[[o,e.y],[e.x,e.y],[e.x,r],[o,r]];for(let e=0;e<c.length;e++)s.intersectRect(t.x,t.y,t.r,c[e][0],c[e][1],c[e][0]+h,c[e][1]+n)&&i.push(e);return i}static intersectRect(t,e,s,i,h,n,o){const r=t-Math.max(i,Math.min(t,n)),c=e-Math.max(h,Math.min(e,o));return r*r+c*c<s*s}}class i{constructor(t){this.x1=t.x1,this.y1=t.y1,this.x2=t.x2,this.y2=t.y2,this.data=t.data||{}}static getIndex(t,e){const s=[],h=e.width/2,n=e.height/2,o=e.x+h,r=e.y+n,c=[[o,e.y],[e.x,e.y],[e.x,r],[o,r]];for(let e=0;e<c.length;e++)i.containsSegment(t.x1,t.y1,t.x2,t.y2,c[e][0],c[e][1],c[e][0]+h,c[e][1]+n)&&s.push(e);return s}static containsSegment(t,e,s,i,h,n,o,r){if(t<=h&&s<=h||e<=n&&i<=n||t>=o&&s>=o||e>=r&&i>=r)return!1;const c=(i-e)/(s-t);let d=c*(h-t)+e;if(d>n&&d<r)return!0;if(d=c*(o-t)+e,d>n&&d<r)return!0;let a=(n-e)/c+t;return a>h&&a<o||(a=(r-e)/c+t,a>h&&a<o)}}return Object.assign(e,{Rectangle:t,Circle:s,Line:i})}));
