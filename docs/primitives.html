
<!doctype html>
<html>
	<head>
		<title>quadtree-js Primitives Demo</title>
		<link rel="stylesheet" type="text/css" href="style.css?v=2" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />

		<!-- prism syntax highlighting (https://prismjs.com/) -->
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.21.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" />
	</head>
	<body>

		<div class="outer">
			
			<h1><a href="https://github.com/timohausmann/quadtree-js">quadtree-js</a> <small>primitives example</small></h1>

			<nav>
				<strong>Demos:</strong>
				<a href="simple.html">simple</a>
				<a href="dynamic.html">dynamic</a>
				<a href="many.html">many to many</a>
				<a href="test-10000-1.2.0.html">benchmark</a>
				<span>primitives</span>
			</nav>
			
			<div id="canvasContainer">
				<canvas id="canvas" width="640" height="480"></canvas>
			</div>

			<div class="ctrl">
				<div class="ctrl-left">
					<button id="btn_rect">Rect Cursor</button>
					<button id="btn_circle">Circle Cursor</button>
					<button id="btn_line">Line Cursor</button>
				</div>

				<div class="ctrl-right">
					Total Objects: <span id="cnt_total">0</span><br />
					Candidates: <span id="cnt_cand">0</span> (<span id="cnt_perc">0</span>%)
				</div>
			</div>
		

			<p>
				This example demonstrates Rects, Circles and Lines.
			</p>


		</div>

		<!-- github corner (https://github.com/tholman/github-corners) -->
		<a href="https://github.com/timohausmann/quadtree-js" class="github-corner" aria-label="View source on GitHub"
			target="_blank" rel="noopener noreferrer">
			<svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true">
				<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
			</svg>
		</a>

		<!-- prism syntax highlighting -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.21.0/prism.min.js" integrity="sha512-WkVkkoB31AoI9DAk6SEEEyacH9etQXKUov4JRRuM1Y681VsTq7jYgrRw06cbP6Io7kPsKx+tLFpH/HXZSZ2YEQ==" crossorigin="anonymous"></script>

        <!-- quadtree lib -->
		<script src="../dist/quadtree.umd.all.js"></script>
        
        <!-- example helpers -->
		<script src="./example.js"></script>

		<!-- example script -->
		<script>

			const ctx = document.getElementById('canvas').getContext('2d'),
            cnt_total = document.querySelector('#cnt_total'),
			cnt_cand = document.querySelector('#cnt_cand'),
			cnt_perc = document.querySelector('#cnt_perc');
            
            let isMouseover = false;
			
			//the main Quadtree
			const myTree = new Quadtree({
				x: 0,
				y: 0,
				width: 640,
				height: 480
			});
			
			//our objects will be stored here
			const myObjects = [];
						
			//our "hero" (cursor)
			const rectCursor = new Quadtree.Rectangle({
				x: 0,
				y: 0,
				width: 40,
                height: 40
			});
            
            const circleCursor = new Quadtree.Circle({
                x: 0, 
                y: 0, 
                r: 42
            });

            const lineCursor = new Quadtree.Line({
                x1: 50, 
                y1: 50, 
                x2: 150,
                y2: 150,
                data: {
                    x: 0,
                    y: 0
                }
            });

            let myCursor = lineCursor;

            //change cursor on button click
            document.querySelector('#btn_rect').addEventListener('click', () => myCursor = rectCursor);
            document.querySelector('#btn_line').addEventListener('click', () => myCursor = lineCursor);
            document.querySelector('#btn_circle').addEventListener('click', () => myCursor = circleCursor);
			
			
			//create some objects and save them in myObjects
			function createObjects() {
				for(var i=0;i<200;i=i+1) {

                    let rand = Math.random();

                    if(rand > 0.66) {
                        myObjects.push({
                            x: randMinMax(0, 640),
                            y: randMinMax(0, 480),
                            width: randMinMax(10, 20),
                            height: randMinMax(10, 20),
                            vx: randMinMax(-0.5,0.5),
                            vy: randMinMax(-0.5,0.5),
                            check: false,
                            getIndex: Quadtree.Rectangle.getIndex
                        });
                    } else if(rand > 0.33) {
                        myObjects.push({
                            x: randMinMax(0, 640),
                            y: randMinMax(0, 480),
                            r: randMinMax(5, 10),
                            vx: randMinMax(-0.5,0.5),
                            vy: randMinMax(-0.5,0.5),
                            check: false,
                            getIndex: Quadtree.Circle.getIndex
                        });
                    } else {

                        var x = randMinMax(0, 640);
                        var y = randMinMax(0, 480);
                        var rad = Math.PI * Math.random();
                        var len = Math.random() * 30;

                        //note: the required keys x1, y1, x2, y2 for Line are set later dynamically
                        var line = {
                            x: x,
                            y: y,
                            rad: rad,
                            len: len,
                            vx: randMinMax(-0.5,0.5),
                            vy: randMinMax(-0.5,0.5),
                            check: false,
                            getIndex: Quadtree.Line.getIndex
                        };

                        myObjects.push(line);

                        updateLineXY(line);

                    }
				}

				updateTotal();
			};


            function updateLineXY(line) {

                line.x1 = line.x + Math.sin(line.rad) * line.len;
                line.y1 = line.y + Math.cos(line.rad) * line.len;
                line.x2 = line.x + Math.sin(line.rad) * -line.len;
                line.y2 = line.y + Math.cos(line.rad) * -line.len;
            }
			
			
			//main loop
			function loop() {
				
				var candidates = [];
				
				//clear the tree
				myTree.clear();
				ctx.clearRect(0, 0, 640, 480);
				
				//update myObjects and insert them into the tree again
				for(var i=0;i<myObjects.length;i=i+1) {
					
					myObjects[i].x += myObjects[i].vx;
					myObjects[i].y += myObjects[i].vy;
					myObjects[i].check = false;

                    if(myObjects[i].getIndex === Quadtree.Line.getIndex) {
                        updateLineXY(myObjects[i]);
                    }
					
					if(myObjects[i].x > 640) myObjects[i].x = 0;
					if(myObjects[i].x < 0) myObjects[i].x = 640;
					if(myObjects[i].y > 480) myObjects[i].y = 0;
					if(myObjects[i].y < 0) myObjects[i].y = 480;
					
					
					myTree.insert(myObjects[i]);
				}
				

				if(isMouseover) {

                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)';

                    if(myCursor === lineCursor) {
                        const t = performance.now();
                        myCursor.x1 = myCursor.data.x + Math.sin(t*0.001) * 200;
                        myCursor.y1 = myCursor.data.y + Math.cos(t*0.001) * 200;
                        myCursor.x2 = myCursor.data.x + Math.sin(t*0.001) * -200;
                        myCursor.y2 = myCursor.data.y + Math.cos(t*0.001) * -200;

                        ctx.beginPath();
                        ctx.moveTo(myCursor.x1, myCursor.y1);
                        ctx.lineTo(myCursor.x2, myCursor.y2);
                        ctx.stroke();
                    } else if(myCursor === circleCursor) {
                        ctx.beginPath();
                        ctx.arc(myCursor.x, myCursor.y, myCursor.r, 0, 2 * Math.PI);
                        ctx.fill();
                    } else {
                        ctx.fillRect(myCursor.x, myCursor.y, myCursor.width, myCursor.height);
                    }
				
					//retrieve all objects in the bounds of the hero 
					candidates = myTree.retrieve(myCursor);
					
					//flag retrieved objects
					for(i=0;i<candidates.length;i=i+1) {
						candidates[i].check = true;
					}
				}

				updateCandidatesInfo(candidates);
				
				drawQuadtree(myTree, ctx);
				drawObjects(myObjects, ctx);
				
				window.requestAnimationFrame(loop);
			};

            //update UI functions
			function updateTotal() {
				cnt_total.innerHTML = myObjects.length;
			}
			function updateCandidatesInfo(candidates) {

				cnt_cand.innerHTML = candidates.length;
				if(!myObjects.length) return;
				cnt_perc.innerHTML = Math.round((candidates.length/myObjects.length)*100);
			}
			
			//create objects
			createObjects();
			
			//init first loop
			loop();
			
			//set eventListener for mousemove
			//position hero at mouse position
			document.getElementById('canvas').addEventListener('mousemove', function(e) {
				
				isMouseover = true;
				
				if(!e.offsetX) {
					e.offsetX = e.layerX - e.target.offsetLeft;
					e.offsetY = e.layerY - e.target.offsetTop;
				} 
				
				if(myCursor === lineCursor) {
                    myCursor.data.x = e.offsetX;
                    myCursor.data.y = e.offsetY;
                } else if(myCursor === circleCursor) {
                    myCursor.x = e.offsetX;
				    myCursor.y = e.offsetY;
                } else {			
                    myCursor.x = e.offsetX - (myCursor.width/2);
                    myCursor.y = e.offsetY - (myCursor.height/2);	
                }
			});

			//hide hero on mouseout
			document.getElementById('canvas').addEventListener('mouseout', function(e) {
				isMouseover = false;
			});
			
		</script>
	</body>
</html>
